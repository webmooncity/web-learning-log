# React learning, Day 26 (실제: Day 16)
Date : 2026-02-10 Tuesday.

---

# 11장, 컴포넌트 최적화

## 11.1, 컴포넌트 최적화의 개요

* **컴포넌트 최적화**: 리액트 애플리케이션에서 성능을 높이기 위한 기술과 전력을 의미함.
  - 주된 목적은 렌더링 속도를 개선하고, 불피룡한 리렌더링을 줄이는 것.

### 11.1.1, 성능 최적화 방법

- 리액트 애플리케이션의 성능을 높이는 방법
  1. **일반적인 웹 최적화 방법**
  2. **리액트 특화 최적화 방법**
    * React.memo: 불필요한 리렌더링 방지
    * React.lazy: 필요한 시점에 컴포넌트를 불러오는 코드 스플리팅
    * useMemo, useCallback: 복잡한 연산 결과나 함수를 메모이제이션
    * useTransition, useDeferredValue: 상태 업데이트를 비동기적으로 지연 처리

### 11.1.2, 불필요한 리렌더링

* 컴포넌트 트리에는 한가지 중요한 특징이 있음: 상위 컴포넌트가 리렌더링되면 그에 연결된 하위 컴포넌트들도 함께 리렌더링된다는 점
* **불필요한 리렌더링**: 실제로 변경된 내용이 없는데도 컴포넌트가 리렌더링되는 현상.

### 11.1.3, 메모이제이션

* **메모이제이션**(memoization): 이미 계산한 결과를 저장해두고 같은 계산을 반복해야 할 때 저장된 값을 다시 사용하는 최적화 기법.
  * React.memo: 컴포넌트 자체를 메모이제이션
  * useCallback: 함수를 메모이제이션
  * useMemo: 계산된 값을 메모이제이션

---

## 11.2, 컴포넌트 메모이제이션

* **컴포넌트 자체를 메모이제이션**

## 11.2.1, React.memo 사용하기

* **고차 컴포넌트**(higher order component): 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 함수를 의미함.
  - 형식: `const MemoizedComponent = React.memo(MyComponent);`

## 11.2.2, React.memo 사용 시 주의사항

---

## 11.3, 함수 메모이제이션.

## 11.3.1, 함수를 props로 전달하는 경우

- 자바스크립트에서 함수, 배열, 객체는 모두 **참조 자료형**(reference type)
  - 참조 자료형은 변수에 값 자체가 저장되는 것이 아니라 값이 저장된 메모리 주소(참조 값)가 저장됨.

## 11.3.2, useCallback 훅 사용하기

* useCallback 훅
  - 형식: `const cachedFn = useCallback(fun, dependencies);`
    - fn: 메모이제이션할 함수
    - dependencies: 의존성 배열

## 11.3.3, useCallback 훅 사용 시 주의사항

* 상태 변경 함수를 콜백 함수 형태로 사용하기
  - **클로저**(Closure): 자바스크립트의 함수는 정의될 때 해당 시점의 변수 상태를 캡처해서 기억하는 클로저(Closure)라는 특성이 있음.
* 의존성 배열에 상태 값을 포함하지 않기
  - useCallback 훅을 사용할 때는 의존성 배열에 어떤 값을 포함할지 신중하게 판단해야 함.

* 함수의 참조값: 그 함수 객체의 정체성(메모리 주소 같은 것), === 비교 기준.

- 개념 정리: 참조 비교, 얕은 비교, 깊은 비교.

---