# React learning, Day 04
Date : 2026-01-19 Monday

---

## 3.5, 컴포넌트와 이벤트

- 이벤트(event): 사용자와의 상호작용에 따라 발생하는 일련의 사건을 의미함
- ```TSX
  <JSXElement 이벤트_속성='이벤트_핸들러'/>
  ```

- HTML에서는 이벤트 속성을 소문자로 작성하고, 값은 문자열 형태의 자바스크립트 코드로 작성합니다.
  반면에 리액트(JSX)에서는 이벤트 속성을 카멜케이스로 작성하고, 값으로 함수를 전달합나다.

- 이벤트 핸들러
  - 인라인 핸들러(inline handler): 이벤트 속성 안에 함수를 직접 작성하는 방식
  - 함수 참조:
    * 함수 참조 방식을 사용할 때 함수명 뒤에 괄호를 붙이면 안 됩니다.
  - 이벤트 핸들러의 매개변수 : 이벤트 핸들러에 매개변수를 전달할 때 인라인 핸들러 방식을 사용해야 함.

- 이벤트 객체(event object)
  : 기본 DOM 이벤트 객체(native DOM event object)와는 다름.
  - **합성 이벤트**(synthetic event)를 사용.
    - 이를 '크로스브라우저 호환성(cross-browser compatibility)을 확보한다'고 표현


* 잠시 개념 정리
  - 리터럴(literal): 값 그 자체를 코드에 직접 적어 놓은 표현
  - 함수 리터럴? 함수를 '정의'하면서 동시에 '값으로 만드는 표현'
  * 값(value)와 데이터(data)의 차이
    - 값(value): 변수에 들어갈 수 있는 실제 내용물
    - 데이터(data): 프로그램이 다루는 모든 값의 총칭
    - JS에서는 거의 동일하게 사용

- 이벤트 객체와 인라인 핸들러
- 이벤트 객체와 함수 참조
- 이벤트 객체와 매개변수


### 3.5.4, 이벤트 전파(event propagation)

* 이벤트 전파(event propagation)란 이벤트가 발생했을 때 부모 또는 자식 요소로 전달되는 현상을 의미.
  - 캡처링(capturing): 이벤트가 부모 요소에서 시작해 자식 요소로 내려가는 방식
  - 버블링(bubbling): 이벤트가 자식 요소에서 시작해 부모 요소로 전파되는 방식

  - 이벤트 전파 막기: stopPropagation() 메서드
  - 이벤트 기본 동작 막기: preventDefault() 메서드

## 마무리

* 컴포넌트: UI를 구성하는 독립적이고 재사용 가능한 작은 단위
- 이벤트 속성은 카멜케이스로 작성.

---

## Selfcheck

1. 버튼(button)을 렌더링하는 Button 컴포넌트를 만듬
2. Button 컴포넌트에는 버튼의 내용과 이벤트 핸들러를 전달.
3. Button 컴포넌트는 부모 컴포넌트에서 전달한 내용과 이벤트 핸들러를 받아 내용은 렌더링하고 이벤트 핸들러는 클릭 이벤트 속성에 할당.
4. 버튼을 클릭하면 부모 컴포넌트에서 전달받은 이벤트 핸들러가 실행. 이벤트 핸들러의 로직은 자유롭게 구현.

---

# 4장, 컴포넌트 상태

리액트 애플리케이션이 단순한 정적 페이지를 넘어 동적으로 변화하는 UI를 제공할 수 있는 이유는 바로 **상태 관리** 덕분.

## 4.1, 컴포넌트의 상태란?

* **컴포넌트의 상태**(state)란? 리액트 컴포넌트 내부에서 관리하는 데이터로, 사용자와의 상호작용에 따라 변경될 수 있는 값을 의미.

---

## 4.2, useState 훅: 기본 상태 관리

* **훅**(hook)이란 함수형 컴포넌트에서 상태(state)와 생명주기(lifecycle)를 쉽게 관리할 수 있도록 도와주는, 리액트에서 제공하는 특별한 함수.
- 가장 대표적인 훅으로는 useState와 useReducer가 있다.

- useState 훅 형식
  `const [state, setState] = useState<Type>(initialState)`

- **제네릭**(generic): 타입스크립트에서는 특정 타입에 고정되지 않고, 다양한 타입에서 재사용할 수 있는 기능인 제네릭(generic)을 제공

- 이전 상태 값을 참조하는 방식: 상태 변경 함수에 콜백 함수(callback function)를 전달하면 업데이트 이전 상태 값이 함수의 매개 변수로 전달됨.
- 형식 `상태_변경_함수((이전_상태_값) => 변경할_상태_값)`

### 4.2.2, useState 훅 사용하기

* 이전 상태 값을 기준으로 상태를 변경할 때는 setCount(count + 1)처럼 작성해도 되지만, 필자는 setCount(count => count + 1)처럼 콜백 함수 형태로 작성하는 방식을 더 권장합니다. 이 방식은 상태 값을 안전하게 참조할 수 있어 예기치 않은 문제를 방지할 수 있습니다.
* 위, setCount는 값을 받으면 그 값을 새 상태로 쓰고,
  함수를 받으면 리액트가 그 함수를 "업데이트 직전의 최신 상태"를 넣어서 실행한 뒤, 그 반환값을 새 상태로 사용한다.

* 공부법: 지금 핵심 개념인가? 같이 파고들기.
  뒤에서 또 나올 개념인가? 메모만 하고 진행!

---

## 4.3, useReducer 훅: 복잡한 상태 관리

### 4.3.1, useReducer 훅 기본 문법

- 형식 `const [state, dispatch] = useReducer<Type>(reducer, initialState);`
- **리듀서 함수**(reducer function)
- **액션 발생 함수**(dispatch function)

* 액션과 액션 발생 함수
  * **액션**(action)은 리듀서 함수에서 어떤 상태 변경을 수행할지 결정하기 위해 참조하는 값.
  - 액션 형식 `{ type: 'ACTION_TYPE', payload: 데이터 };`
  - 액션 발생 함수 형식 `dispatch({ type: 'ACTION_TYPE' })`

- 파일 확장자
  * .tsx: JSX를 포함하는 파일(컴포넌트)
  * .ts: 유틸 함수, 리듀서, 타입 선언, API 모듈 등 JSX가 없는 파일

---